---
layout: default
---

<article id="installation">
    <header><h2>Installation</h2></header>
    <p>There are two options when approaching DbCharmer installation:</p>
    <ul>
    <li>
    <p>using the gem (recommended and the only way of using it with Rails 3.0+)</p>
    </li>
    <li>
    <p>install as a Rails plugin (works in Rails 2.x only)</p>
    </li>
    </ul><p>To install as a gem, add this to your Gemfile:</p>

    {% highlight ruby %}gem 'db-charmer', :require => 'db_charmer'{% endhighlight %}

    <p>To install DbCharmer as a Rails plugin use the following command:</p>

    {% highlight console %}./script/plugin install git://github.com/kovyrin/db-charmer.git{% endhighlight %}

    <p><em>Notice:</em> If you use DbCharmer in a non-rails project, you
    may need to set <code>DbCharmer.env</code> to a correct value before using any
    of its connection management methods. Correct value here is a valid
    <tt>database.yml</tt> first-level section name.</p>
</article>


<article id="connections">
  <header><h2>Easy ActiveRecord Connection Management</h2></header>

  <p>As a part of this plugin we’ve added <code>switch_connection_to</code> method
  that accepts many different kinds of db connections specifications and uses
  them on a model. We support:</p>
  <ol>
    <li>Strings and symbols as the names of connection configuration blocks in <tt>database.yml</tt></li>
    <li>ActiveRecord models (we’d use connection currently set up on a model)</li>
    <li>Database connections (<code>Model.connection</code>)</li>
    <li><tt>Nil</tt> values to reset model to default connection</li>
  </ol>

  <p>Sample code:</p>

{% highlight ruby %}
class Foo < ActiveRecord::Model; end

Foo.switch_connection_to(:blah)
Foo.switch_connection_to('foo')
Foo.switch_connection_to(Bar)
Foo.switch_connection_to(Baz.connection)
Foo.switch_connection_to(nil)

{% endhighlight %}

  <p>Sample <tt>database.yml</tt> configuration:</p>

{% highlight yaml %}
production:
  blah:
    adapter: mysql
    username: blah
    host: blah.local
    database: blah

  foo:
    adapter: mysql
    username: foo
    host: foo.local
    database: foo
{% endhighlight %}

  <p>The <code>switch_connection_to</code> method has an optional second parameter
  <tt>should_exist</tt> which is <tt>true</tt> by default. This parameter is used when
  the method is called with a string or a symbol connection name and there is
  no such connection configuration in the <tt>database.yml</tt> file. If this
  parameter is <tt>true</tt>, an exception would be raised, otherwise, the
  error would be ignored and no connection change would happen.</p>

  <p>This is really useful when in development mode or in a tests you do not
  want to create many different databases on your local machine and just want
  to put all your tables in a single database.</p>

  <p><em>Warning:</em> All the connection switching calls would switch connection
  <strong>only</strong> for those classes the method called on. You can’t call the
  <code>switch_connection_to</code> method and switch connection for a base class
  in some hierarchy (for example, you can’t switch <tt>ActiveRecord::Base</tt> connection and
  see all your models switched to the new connection, use the classic
  <code>establish_connection</code> instead).</p>
</article>


<article id="migrations">
  <header><h2>Multiple DB Migrations</h2></header>

  <p>In every application that works with many databases, there is need in a
  convenient schema migrations mechanism.</p>

  <p>All Rails users already have this mechanism – rails migrations. So in
  DbCharmer, we’ve made it possible to seamlessly use multiple
  databases in Rails migrations.</p>

  <p>There are two methods available in migrations to operate on more than one
  database:</p>
  <ol>
  <li>
  <p>Global connection change method – used to switch whole migration to a
  non-default database.</p>
  </li>
  <li>
  <p>Block-level connection change method – could be used to do only a part of a
  migration on a non-default db.</p>
  </li>
  </ol><p>Migration class example (global connection rewrite):</p>

{% highlight ruby %}
class MultiDbTest < ActiveRecord::Migration
  db_magic :connection => :second_db

  def self.up
    create_table :test_table, :force => true do |t|
      t.string :test_string
      t.timestamps
    end
  end

  def self.down
    drop_table :test_table
  end
end
{% endhighlight %}

  <p>Migration class example (block-level connection rewrite):</p>

{% highlight ruby %}
class MultiDbTest < ActiveRecord::Migration
  def self.up
    on_db :second_db do
      create_table :test_table, :force => true do |t|
        t.string :test_string
        t.timestamps
      end
    end
  end

  def self.down
    on_db :second_db { drop_table :test_table }
  end
end
{% endhighlight %}


  <p>Migration class example (global connection rewrite, multiple connections
  with the same table):</p>

{% highlight ruby %}
class MultiDbTest < ActiveRecord::Migration
  db_magic :connections => [:second_db, :default]

  def self.up
    create_table :test_table, :force => true do |t|
      t.string :test_string
      t.timestamps
    end
  end

  def self.down
    drop_table :test_table
  end
end
{% endhighlight %}

  <p><em>Notice:</em> both <tt>:connection</tt> and <tt>:connections</tt> can take an array of connections)</p>

  <h3>Default Migrations Connection</h3>

  <p>Starting with DbCharmer version 1.6.10 it is possible to call
  <code>ActiveRecord::Migration.db_magic</code> and specify default migration
  connection that would be used by all migrations without explicitly
  switched connections. If you want to switch your migration to the default
  ActiveRecord connection, just use
  <code>db_magic :connection => :default</code>.</p>

  <h3>Invalid Connection Names Handling</h3>

  <p>By default in all environments <code>on_db</code> and <code>db_magic</code>
  statments would fail if specified connection does not exist in
  <tt>database.yml</tt>. It is possible to make DbCharmer ignore such
  situations in non-production environments so that rails would create the
  tables in your single database (especially useful in test databases).</p>

  <p>This behaviour is controlled by the
  <code>DbCharmer.connections_should_exist</code> configuration attribute which
  could be set from a rails initializer.</p>

  <p><em>Warning:</em> if in test environment you use separate connections and
  master-slave support in DbCharmer, make sure you disable transactional
  fixtures support in Rails. Without this change you’re going to see all
  kinds of weird data visibility problems in your tests.</p>
</article>


<article id="master-slave">
  <header><h2>Using Models in Master-Slave Environments</h2></header>

  <p>Master-slave replication is the most popular scale-out technique in a
  medium-sized and large database-centric applications today. There are some
  rails plugins out there that help developers to use slave servers in their
  models but none of them were flexible enough for us to start using them in
  a huge application we work on.</p>

  <p>So, after using ActsAsReadonlyable plugin for some time, upon switching to
  Rails 2.2 we’ve decided to collect all of our master-slave code in one plugin
  and release it. DbCharmer adds the following features to Rails models:</p>

  <h3>Auto-Switching all Reads to the Slave(s)</h3>

  <p>When you create a model, you could use <code>db_magic :slave => :blah</code>
  or <code>db_magic :slaves => [ :foo, :bar ]</code> commands in your model to
  set up reads redirection mode when all your <tt>find</tt>/<tt>count</tt>/<tt>exist</tt>/etc methods
  will be reading data from your slave (or a bunch of slaves in a round-robin
  manner). Here is an example:</p>

{% highlight ruby %}
class Foo < ActiveRecord::Base
  db_magic :slave => :slave01
end

class Bar < ActiveRecord::Base
  db_magic :slaves => [ :slave01, :slave02 ]
end
{% endhighlight %}

  <h3>Default Connection Switching</h3>

  <p>If you have more than one master-slave cluster (or simply more than one
  database) in your database environment, then you might want to change the
  default database connection of some of your models. You could do that by
  using <code>db_magic :connection => :foo</code> call from your models.
  Example:</p>

{% highlight ruby %}
class Foo < ActiveRecord::Base
  db_magic :connection => :foo
end
{% endhighlight %}

  <p>Sample model on a separate master-slave cluster (so, separate main
  connection + a slave connection):</p>

{% highlight ruby %}
class Bar < ActiveRecord::Base
  db_magic :connection => :bar, :slave => :bar_slave
end
{% endhighlight %}

  <h3>Per-Query Connection Management</h3>

  <p>Sometimes you have select queries that you know you want to run on the
  master. This could happen for example when you have just added some data
  and need to read it back and not sure if it made it all the way to the
  slave yet or no. For this situation and a few others there is a set of
  methods we’ve added to ActiveRecord models:</p>

  <ol>
  <li><p><code>on_master</code> – this method could be used in two forms: block form
  and proxy form. In the block form you could force connection switch for a
  block of code:</p>

{% highlight ruby %}
User.on_master do
  user = User.find_by_login('foo')
  user.update_attributes!(:activated => true)
end
{% endhighlight %}

  <p>In the proxy form this method could be used to force one query to be
  performed on the master database server:</p>

{% highlight ruby %}
Comment.on_master.last(:limit => 5)
User.on_master.find_by_activation_code(code)
User.on_master.exists?(:login => login, :password => password)
{% endhighlight %}
  </li>

  <li><code>on_slave</code> – this method is used to force a query to be run on a
  slave even in situations when it’s been previously forced to use the
  master. If there is more than one slave, one would be selected randomly.
  This method has two forms as well: block and proxy.</li>

  <li><p><code>on_db(connection)</code> – this method is what makes two previous
  methods possible. It is used to switch a model’s connection to some db
  for a short block of code or even for one statement (two forms). It accepts
  the same range of values as the <code>switch_connection_to</code> method does.
  Example:</p>

{% highlight ruby %}
Comment.on_db(:olap).count
Post.on_db(:foo).first
{% endhighlight %}

  <p>By default in development and test environments you could use non-existing
  connections in your <code>on_db</code> calls and rails would send all your
  queries to a single default database. In production <code>on_db</code> won’t
  accept non-existing names.</p>

  <p>This behaviour is controlled by the
  <code>DbCharmer.connections_should_exist</code> configuration attribute which
  could be set from a rails initializer.</p>
  </li>
  </ol>

  <h3>Forced Slave Reads</h3>

  <p>In some cases we could have models that are too important to be used in
  default “send all reads to the slave” mode, but we still would like to
  be able to switch them to this mode sometimes. For example, you could have
  <tt>User</tt> model, which you would like to keep from lagging with your
  slaves because users do not like to see outdated information about their
  accounts. But in some cases (like logged-out profile page views, etc) it
  would be perfectly reasonable to switch all reads to the slave.</p>

  <p>For this use-case starting with DbCharmer release 1.7.0 we have a
  feature called forced slave reads. It consists of a few separate small
  features that together make it really powerful:</p>

  <ol>
  <li><p><code>:force_slave_reads => false</code> option for
  ActiveRecord‘s <code>db_magic</code> method. This option could be
  used to disable automated slave reads on your models so that you could call
  <code>on_slave</code> or use other methods to enable slave reads when you need
  it. Example:</p>

{% highlight ruby %}
class User < ActiveRecord::Base
  db_magic :slave => slave01, :forced_slave_reads => false
end
{% endhighlight %}
  </li>

  <li><p><code>ActionController.force_slave_reads</code> class method. This
  method could be used to enable per-controller (when called with no
  arguments), or per-action (<tt>:only</tt> and <tt>:except</tt> params)
  forced reads from slaves. This is really useful for actions in which you
  know you could tolerate some slave lag so all your models with slaves
  defined will send their reads to slaves. Example:</p>

{% highlight ruby %}
class ProfilesController < Application
  force_slave_reads :except => [ :login, :logout ]
  # ...
end
{% endhighlight %}
  </li>

  <li><p><code>ActionController#force_slave_reads!</code> instance method,
  that could be used within your actions or in controller filters to
  temporarily switch your models to forced slave reads mode. This method
  could be useful for cases when the same actions could be called by
  logged-in  and anonymous users. Then you could authorize users in
  <code>before_filter</code> and call <code>force_slave_reads!</code> method for
  anonymous page views.</p>

{% highlight ruby %}
class ProfilesController < Application
  before_filter do
    force_slave_reads! unless current_user
  end
  # ...
end
{% endhighlight %}

  <p><em>Notice:</em> Before using this method you need to enable
  ActionController support in DbCharmer. You need to call
  <code>DbCharmer.enable_controller_magic!</code> method from your project
  initialization code.</p>
  </li>

  <li><p><code>DbCharmer.force_slave_reads</code> method that could be used with a
  block of ruby code and would enable forced slave reads mode until the end
  of the block execution. This is really powerful feature allowing high
  granularity in your control of forced slave reads mode. Example:</p>

{% highlight ruby %}
DbCharmer.force_slave_reads do
  # ...
  total_users = User.count
  # ...
end
{% endhighlight %}

  <p><em>Notice:</em> At this point the feature considered beta and should be used with
  caution. It is fully covered with tests, but there still could be
  unexpected issues when used in real-world applications.</p>
  </li>
  </ol>

  <h3>Associations Connection Management</h3>

  <p>ActiveRecord models can have an associations with each other and since
  every model has its own database connections, it becomes pretty hard to
  manage connections in a chained calls like <code>User.posts.count</code>. With
  a class-only connection switching methods this call would look like the
  following if we’d want to count posts on a separate database:</p>

{% highlight ruby %}
Post.on_db(:olap) { User.posts.count }
{% endhighlight %}

  <p>Apparently this is not the best way to write the code and we’ve
  implemented an <tt>on_*</tt> methods on associations as well so you could
  do things like this:</p>

{% highlight ruby %}
@user.posts.on_db(:olap).count
@user.posts.on_slave.find_by_title('Hello, world!')
{% endhighlight %}

  <p><em>Notice:</em> Since ActiveRecord associations implemented as proxies for
  resulting objects/collections, it is possible to use our connection
  switching methods even without chained methods:</p>

{% highlight ruby %}
@post.user.on_slave   # would return post's author
@photo.owner.on_slave # would return photo's owner
{% endhighlight %}

  <p>Starting with DbCharmer release 1.4 it is possible to use prefix
  notation for <tt>has_many</tt> and HABTM associations connection switching:</p>

{% highlight ruby %}
@user.on_db(:foo).posts
@user.on_slave.posts
{% endhighlight %}

  <h3>Named Scopes Support</h3>

  <p>To make it easier for DbCharmer users to use connections switching
  methods with named scopes, we’ve added <tt>on_*</tt> methods support on
  the scopes as well. All the following scope chains would do exactly the
  same way (the query would be executed on the <tt>:foo</tt> database connection):</p>

{% highlight ruby %}
Post.on_db(:foo).published.with_comments.spam_marked.count
Post.published.on_db(:foo).with_comments.spam_marked.count
Post.published.with_comments.on_db(:foo).spam_marked.count
Post.published.with_comments.spam_marked.on_db(:foo).count
{% endhighlight %}

  <p>And now, add this feature to our associations support and here is what we
  could do:</p>

{% highlight ruby %}
@user.on_db(:archive).posts.published.all
@user.posts.on_db(:olap).published.count
@user.posts.published.on_db(:foo).first
{% endhighlight %}

  <h3>Bulk Connection Management</h3>

  <p>Sometimes you want to run code where a large number of tables may be used,
  and you’d like them all to use an alternate database. You can now do
  this:</p>

{% highlight ruby %}
DbCharmer.with_remapped_databases(:logs => :big_logs_slave) { ... }
{% endhighlight %}

  <p>Any model whose default database is <tt>:logs</tt> (e.g., <code>db_charmer
  :connection => :logs</code>) will now have its connection switched to
  <tt>:big_logs_slave</tt> in that block. This is lower precedence than any
  other DbCharmer method, so <code>Model.on_db(:foo).find(...)</code>
  and such things will still use the database they specify, not the one that
  model was remapped to.</p>

  <p>You can specify any number of remappings at once, and you can also use
  <tt>:master</tt> as a database name that matches any model that has not had
  its connection set by DbCharmer at all.</p>

  <p><em>Notice:</em> DbCharmer works via <code>alias_method_chain</code> in
  model classes. It is very careful to only patch the models it needs to.
  However, if you use <code>with_remapped_databases</code> and remap the default
  database (<tt>:master</tt>), then it has no choice but to patch all
  subclasses of <tt>ActiveRecord::Base</tt>. This should not cause any serious
  problems or any big performance impact, but it is worth noting.</p>
</article>


<article id="sharding">
  <header><h2>Simple Sharding Support</h2></header>

  <p>Starting with the release 1.6.0 of DbCharmer we have added support
  for simple database sharding to our ActiveRecord extensions. Even though
  this feature is tested in production, we do not recommend using it in your
  applications without complete understanding of the principles of its work.</p>

  <p>At this point we support four sharding methods:</p>

  <ol>
  <li><code>range</code> – really simple sharding method that allows you to take a
  table, slice is to a set of smaller tables with pre-defined ranges of
  primary keys and then put those smaller tables to different
  databases/servers. This could be useful for situations where you have a
  huge table that is slowly growing and you just want to keep it simple and
  split the table load into a few servers without building any complex
  sharding schemes.</li>

  <li><code>hash_map</code> – pretty simple sharding method that allows you to
  take a table and slice it to a set of smaller tables by some key that has a
  pre-defined key of values. For example, list of US mailing addresses could
  be sharded by states, where you’d be able to define which states are
  stored in which databases/servers.</li>

  <li><code>db_block_map</code> – this is a really complex sharding method that
  allows you to shard your table into a set of small fixed-size blocks that
  then would be assigned to a set of shards (databases/servers). Whenever you
  would need an additional blocks they would be allocated automatically and
  then balanced across the shards you have defined in your database. This
  method could be used to scale out huge tables with hundreds of millions to
  billions of rows and allows relatively easy re-sharding techniques to be
  implemented on top.</li>

  <li><code>db_block_group_map</code> – really similar to the
  <code>db_block_map</code> method with a single difference: this method allows
  you to have a set of databases (table groups) on each server and every
  group would be handled as a  separate shard of data. This approach is
  really useful for pre-sharding of your data before scaling your application
  out. You can easily start with one server, having 10-20-50 separate
  databases, and then move those databases to different servers as you see
  your database outgrow one machine.</li>
  </ol>


  <h3>How to enable sharding?</h3>

  <p>To enable sharding extensions you need to take a few things:</p>

  <ol>
    <li>Create a Rails initializer (on run this code when you initialize your
    script/application) with a set of sharded connections defined. Each
    connection would have a name, sharding method and an optional set of
    parameters to initialize the sharding method of your choice.</li>

    <li>Specify sharding connection you want to use in your models.</li>

    <li>Specify the shard you want to use before doing any operations on your models.</li>
  </ol>

  <p>For more details please check out the following documentation sections.</p>


  <h3>Sharded Connections</h3>

  <p>Sharded connection is a simple abstractions that allows you to specify all
  sharding parameters for a cluster in one place and then use this
  centralized configuration in your models. Here are a few examples of
  sharded connections initialization calls:</p>

  <ol>
  <li><p>Sample range-based sharded connection:</p>

{% highlight ruby %}
TEXTS_SHARDING_RANGES = {               # This hash maps possible key ranges to db connections
  0...100  => :shard1,
  100..200 => :shard2,
  :default => :shard3
}

DbCharmer::Sharding.register_connection(
  :name   => :texts,
  :method => :range,
  :ranges => TEXTS_SHARDING_RANGES      # Pass our mapping to the sharding method
)
{% endhighlight %}
  </li>

  <li><p>Sample hash map sharded connection:</p>

{% highlight ruby %}
SHARDING_MAP = {                        # This hash will map our keys to db connections
  'US'      => :us_users,
  'CA'      => :ca_users,
  :default  => :other_users
}

DbCharmer::Sharding.register_connection(
  :name   => :users,
  :method => :hash_map,
  :map    => SHARDING_MAP               # Pass our map to the sharding method
)
{% endhighlight %}
  </li>

  <li><p>Sample database block map sharded connection:</p>

{% highlight ruby %}
DbCharmer::Sharding.register_connection(
  :name         => :social,
  :method       => :db_block_map,
  :block_size   => 10000,               # Number of keys per block
  :map_table    => :event_shards_map,   # Table with blocks to shards mapping
  :shards_table => :event_shards_info,  # Shards connection information table
  :connection   => :social_shard_info   # What connection to use to read the map
)
{% endhighlight %}
  </li>
  </ol>

  <p>After your sharded connection is defined, you could use it in your models:</p>

{% highlight ruby %}
class Text < ActiveRecord::Base
  db_magic :sharded => {
    :key => :id,
    :sharded_connection => :texts
  }
end

class Event < ActiveRecord::Base
  db_magic :sharded => {
    :key => :to_uid,
    :sharded_connection => :social
  }
end
{% endhighlight %}

  <h3>Switching connections in sharded models</h3>

  <p>Every time you need to perform an operation on a sharded model, you need to
  specify on which shard you want to do it. We have a method for this which
  would look familiar for the people that use DbCharmer for
  non-sharded environments since it looks and works just like those per-query
  connection management methods:</p>

{% highlight ruby %}
Event.shard_for(10).where(:to_uid => 123).limit(5)
Text.shard_for(123).find_by_id(123)
{% endhighlight %}

  <p>There is another method that could be used with range and hash_map sharding
  methods, this method allows you to switch to the default shard:</p>

{% highlight ruby %}
Text.on_default_shard.create(:body => 'hello', :user_id => 123)
{% endhighlight %}

  <p>And finally, there is a method that allows you to run your code on each
  shard in the system (at this point the method is supported in db_block_map
  and db_block_group_map methods only):</p>

{% highlight ruby %}
Event.on_each_shard { |event| event.delete_all }
{% endhighlight %}

  <h3>Defining your own sharding methods</h3>

  <p>It is possible with DbCharmer for the users to define their own
  sharding methods. You need to do a few things to implement your very own
  sharding scheme:</p>

  <ol>
  <li>Create a class with a name <code>DbCharmer::Sharding::Method::YourOwnName</code></li>

  <li>Implement at least a constructor <code>initialize(config)</code> and a
  lookup instance method <code>shard_for_key(key)</code> that would return either
  a connection name from <tt>database.yml</tt> file or just a hash of
  connection parameters for rails connection adapters.</li>

  <li><p>Register your sharded connection using the following call:</p>

{% highlight ruby %}
DbCharmer::Sharding.register_connection(
  :name   => :some_name,
  :method => :your_own_name,    # your sharding method class name in lower case
  # ... some additional parameters if needed
)
{% endhighlight %}
  </li>

  <li>Use your sharded connection as any standard one.</li>
  </ol>


  <h3>Adding support for default shards in your custom sharding methods</h3>

  <p>If you want to be able to use <code>on_default_shard</code> method on your
  custom-sharded models, you need to do two things:</p>

  <ol>
    <li>implement <code>support_default_shard?</code> instance method on your
    sharded class that would return <tt>true</tt> if you do support default
    shard specification and <tt>false</tt> otherwise.</li>

    <li>implement <tt>:default</tt> symbol support as a key in your <code>shard_for_key</code> method.</li>
  </ol>


  <h3>Adding support for shards enumeration in your custom sharding methods</h3>

  <p>To add shards enumeration support to your custom-sharded models you need to
  implement an instance method <code>shard_connections</code> on your class. This
  method should return an array of sharding connection names or connection
  configurations to be used to establish connections in a loop.</p>
</article>
